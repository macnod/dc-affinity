;; wikipedia-articles-processor.lisp
;;
;; This program extracts articles from the wiki_XX files that
;; WikiExtractor.py outputs.  The program pulls individual articles
;; from the wiki_XX files and stores the articles in a postgres
;; database.
;;
;; This program should run isolated from the dc-chattermancy
;; workspace, so load it into a separate Emacs instance if running
;; chattermancy.
;; 
(defpackage :dc-wikipedia

  (:use :cl 
        :dc-utilities 
        :cl-ppcre 
        :dc-ngram
        :sb-thread
        :gzip-stream))

(in-package :dc-wikipedia)

;; (defparameter *top-directory* "/home/macnod/data/chattermancy/wikipedia/text")
;; (setf dc-ngram:*valid-trigram-file-name*
;;       "/home/macnod/Dropbox/Code/chattermancy/lib/valid-trigrams-all.dat")

;; (defparameter *group-directories*
;;   (directory (format nil "~a/*" *top-directory*)))

(defparameter *db*
  (ds `(:map
        :db "wikipedia"
        :username "chattermancy"
        :password "weasel1024"
        :host "localhost"
        :retry-count 1
        :retry-sleep 1
        :retry-sleep-factor 1
        :log-function ,(lambda (s) (format t "~a~%" s)))))

;; (defun id-title-content (data)
;;   "Given data consisting of the contents of a file generated by
;; WikiExtractor, find and return the individual articles in the data,
;; without XML."
;;   (mapcar (lambda (x)
;;             (multiple-value-bind (a b)
;;                 (scan-to-strings 
;;                  "(?s)<doc id=\"([^\"]+)\".+?title=\"([^\"]+)\">(.+?)</doc>"
;;                  x)
;;               (declare (ignore a))
;;               (let ((id (read-from-string (elt b 0)))
;;                     (title (trim (elt b 1)))
;;                     (content (trim (elt b 2))))
;;                 (list id title content))))
;;           (all-matches-as-strings "(?s)<doc[^>]+>.+?</doc>" data)))

;; (defun insert-article (wid title content)
;;   "Inserts the given article into the database and returns 1 upon
;; success and 0 if the article already exists."
;;   (if (db-cmd *db* :query
;;               (:select 'id :from 'articles :where (:= 'wid wid)) :single)
;;       0
;;       (progn
;;         (db-cmd *db* :execute (:insert-into 'articles
;;                                :set 'wid wid 'title title 'content content))
;;         1)))

;; (defun delete-article (wid)
;;   (db-cmd *db* :execute (:delete-from 'articles :where (:= 'wid wid))))

;; (defun hr-elapsed-time (total-seconds)
;;   (multiple-value-bind (hours seconds-h)
;;       (truncate total-seconds 3600)
;;     (multiple-value-bind (minutes seconds)
;;         (truncate seconds-h 60)
;;       (format nil "~a:~2,'0d:~2,'0d"
;;               hours minutes seconds))))

;; (defun load-files ()
;;   (loop with progress = 0
;;      with inserts = 0
;;      with insert-start-time = (get-universal-time)
;;      with progress-start-time = (get-universal-time)
;;      for group in *group-directories*
;;      for files = (directory (format nil "~a/*.*" group))
;;      do (loop for file in files
;;            for articles = (id-title-content (slurp file))
;;            do (loop for (id title content) in articles
;;                  do (let ((count (insert-article id title content))
;;                           (progress-elapsed (- (get-universal-time) progress-start-time))
;;                           (insert-elapsed (- (get-universal-time) insert-start-time)))
;;                       (unless (zerop count)
;;                         (when (= insert-start-time progress-start-time)
;;                           (setf insert-start-time (get-universal-time))
;;                           (setf insert-elapsed 0))
;;                         (incf inserts))
;;                       (when (zerop (mod (incf progress) 1000))
;;                         (format t "p=~a i=~a t=~a pr=~a ir=~a~%" 
;;                                 progress
;;                                 inserts
;;                                 (hr-elapsed-time progress-elapsed)
;;                                 (truncate progress (1+ (float progress-elapsed)))
;;                                 (truncate inserts (1+ (float insert-elapsed))))))))))

;; (defun vectorize-articles ()
;;   (loop for articles = (db-cmd *db* :query 
;;                                (:limit
;;                                 (:select 'id 'content :from 'articles :where 
;;                                          (:is-null 'vector))
;;                                 5))
;;      while articles
;;      do (loop for (id content) in articles
;;            for vector = (handler-case
;;                               (trigram-vector content)
;;                           (error (e)
;;                             (format t "error (trigram-vector):'~a'~%id='~a'~%" e id)
;;                             (format nil "error (trigram-vector): ~a" e)))
;;            for nvector = (handler-case
;;                              (normalized-trigram-vector content)
;;                            (error (e)
;;                              (format t "error (normalized-trigram-vector):'~a'~%id='~a'~%" e id)
;;                              (format nil "error (normalized-trigram-vector): ~a" e)))
;;            do (db-cmd *db* :execute
;;                       (:update 'articles :set
;;                                'vector (freeze vector)
;;                                'nvector (freeze nvector)
;;                        :where (:= 'id id))))))

;; (defun count-vectorized ()
;;   (let ((done (db-cmd *db* :query 
;;                       (:select (:count '*) :from 'articles
;;                                :where (:not-null 'nvector))
;;                       :single))
;;         (togo (db-cmd *db* :query 
;;                       (:select (:count '*) :from 'articles
;;                                :where (:is-null 'nvector))
;;                       :single)))
;;     (list :done done :to-go togo 
;;           :percent-done
;;           (format nil "~a%" (truncate (* 100 (/ (float done) (+ done togo))))))))

;; (defun monitor-vectorization (&optional (n 300))
;;   (loop for status = (count-vectorized)
;;      until (zerop (getf status :to-go))
;;      do (format t "~(~{~a=~a~^, ~}~)~%" status)
;;        (sleep n)))

;; (defun delete-short-articles ()
;;   (db-cmd *db* :execute 
;;           (:delete-from 'articles
;;                         :where (:< (:length 'content) 100))))

;; (defun next-reference (last-id &key brief)
;;   (if brief
;;       (db-cmd
;;        *db* :query 
;;        (:limit 
;;         (:order-by
;;          (:select 'id 'wid 'last-comparand 'title
;;                   :from 'articles
;;                   :where
;;                   (:and 
;;                    (:< 'last-comparand last-id)
;;                    (:not-null 'vector)
;;                    (:not-null 'nvector)))
;;          'id) 1) :plist)
;;       (db-cmd
;;        *db* :query 
;;        (:limit 
;;         (:order-by
;;          (:select 'id 'vector 'nvector 'last-comparand 
;;                   :from 'articles
;;                   :where
;;                   (:and 
;;                    (:< 'last-comparand last-id)
;;                    (:not-null 'vector)
;;                    (:not-null 'nvector)))
;;          'id) 1) :row)))

;; (defun article-count ()
;;   (db-cmd *db* :query (:select (:count '*) :from 'articles) :single))

;; (defun comparands (id &key article-count (count 10) brief)
;;   (let ((a-count (1- (or article-count (article-count)))))
;;     (if brief
;;         (db-cmd
;;          *db* :query
;;          (:limit
;;           (:order-by
;;            (:select 'articles.id 'articles.title
;;                     :from 'articles 
;;                     :where 
;;                     (:and (:< 'articles.affinity_count a-count)
;;                           (:!= 'articles.id id)
;;                           (:not-null 'articles.vector)
;;                           (:not-null 'articles.nvector)
;;                           (:not (:exists (:select 'affinity.id :from 'affinity
;;                                                   :where
;;                                                   (:and (:= 'affinity.aid id)
;;                                                         (:= 'affinity.bid 'articles.id)))))))
;;            'articles.id)
;;           count)
;;          :plists)
;;         (db-cmd
;;          *db* :query
;;          (:limit
;;           (:order-by
;;            (:select 'articles.id 'articles.vector 'articles.nvector 
;;                     :from 'articles 
;;                     :where 
;;                     (:and (:< 'articles.affinity_count a-count)
;;                           (:!= 'articles.id id)
;;                           (:not-null 'articles.vector)
;;                           (:not-null 'articles.nvector)
;;                           (:not (:exists (:select 'affinity.id :from 'affinity
;;                                                   :where
;;                                                   (:and (:= 'affinity.aid id)
;;                                                         (:= 'affinity.bid 'articles.id)))))))
;;            'articles.id)
;;           count)))))

;; (defun insert-affinity-record (aid bid score nscore)
;;   (db-cmd *db* :execute
;;           (:insert-into 'affinity 
;;            :set 'aid aid 'bid bid 'score score 'nscore nscore)))

;; (defun increment-affinity-count (id)
;;   (db-cmd *db* :execute
;;           (:update 'articles :set 'affinity-count (:+ 'affinity-count 1)
;;            :where (:= 'id id))))

;; (defun article-affinity (&key last-id count article-count)
;;   (loop with li = (or last-id 
;;                       (db-cmd 
;;                        *db* :query
;;                        (:select (:max 'id) :from 'articles) :single))
;;      for (id1 v1 nv1 last-comparand) = (next-reference li)
;;      do (loop for (id2 v2 nv2) in 
;;              (comparands id1 :article-count article-count :count count)
;;              for affinity = (affinity (thaw v1) (thaw v2))
;;              for naffinity = (affinity (thaw nv1) (thaw nv2))
;;              do (insert-affinity-record id1 id2 affinity naffinity)
;;              (insert-affinity-record id2 id1 affinity naffinity)
;;              (increment-affinity-count id1))))
                                    
;; (defun count-matches ()
;;   (db-cmd *db* :query (:select (:count '*) :from 'affinity)))

;; (defun count-matches-for-title (title)
;;   (db-cmd *db* :query
;;           (:select 'articles.title (:count '*)
;;            :from 'articles
;;            :inner-join 'affinity :on (:= 'articles.id 'affinity.aid)
;;            :where (:= 'articles.title title))))

;; (defun affinity-progress (title n)
;;   (let ((total (db-cmd *db* :query (:select (:count '*) :from 'affinity)))
;;         (top (db-cmd
;;               *db* :query
;;               (:limit
;;                (:order-by
;;                 (:select (:as (:substring 'a2.title 0 40) 'comparand)
;;                          'f.score
;;                  :from (:as 'affinity 'f)
;;                  :inner-join (:as 'articles 'a1) :on (:= 'f.aid 'a1.id)
;;                  :inner-join (:as 'articles 'a2) :on (:= 'f.bid 'a2.id)
;;                  :where (:= 'a1.title title))
;;                 (:desc 'f.score))
;;                n))))
;;     (list :total total
;;           :top-matches-for title
;;           top)))

;; (defun set-affinity-count (n)
;;   (let ((ids (db-cmd *db* :query
;;                      (:limit 
;;                       (:select 'id :from 'articles :where (:= 'affinity-count 0))
;;                       n)
;;                      :column)))
;;     (when ids
;;       (db-cmd *db* :execute 
;;               (:update 'articles
;;                        :set 'affinity-count 
;;                        (:select (:count '*) :from 'affinity
;;                                 :where (:= 'affinity.aid 'articles.id))
;;                        :where (:in 'articles.id (:raw (format nil "(~{~a~^,~})" ids))))))))


;; This function does a crappy job of stopping the threads that
;; contain the given text in the beginning of their name.  However,
;; it's the only thing we have right now.  You'll probably have to
;; call it twice to stop a thread-pool job.
(defun tp-stop (name)
  (let ((threads (remove-if-not 
                  (lambda (x) 
                    (scan (format nil "^~a" name)
                          (sb-thread:thread-name x)))
                  (sb-thread:list-all-threads))))
    (when threads
        (loop for thread in threads
           do (sb-thread:destroy-thread thread)
           finally (sleep 3)
             (return (sb-thread:list-all-threads))))))



;; ----------------------------------------------------------------------
;;
;; affinity-count-update
;;
;; This code is for the thread pool to perform the task of updating
;; the value in the affinity_count column of the articles table.  This
;; code ensures that the value corresponds to the number of
;; affinity-table rows that are associated with each articles-table
;; row.  Start the task with (tp-affinity-count-update n), where n is
;; the size of the thread pool.
;;
;; begin
;;

;; (defun affinity-count-queue ()
;;   (db-cmd *db* :query 
;;           (:limit 
;;            (:select 'articles.id :from 'articles 
;;                     :inner-join 'affinity :on (:or (:= 'articles.id 'affinity.aid)
;;                                                    (:= 'articles.id 'affinity.bid))
;;                     :where
;;                     (:= 'affinity-count 0))
;;            1) :single))

;; (defun affinity-count-job (id)
;;   (db-cmd *db* :execute 
;;           (:update 'articles :set 'affinity-count
;;                    (:select (:count '*) :from 'affinity
;;                             :where (:or (:= 'affinity.aid id)
;;                                         (:= 'affinity.bid id)))
;;                    :where (:= 'articles.id id))))

;; (defun tp-affinity-count-update (thread-count)
;;   (start-thread-pool
;;    "affinity-count-update"
;;    thread-count
;;    #'affinity-count-queue
;;    #'affinity-count-job))

;;
;; end
;;
;; affinity-count-update
;;
;; ----------------------------------------------------------------------


;; ----------------------------------------------------------------------
;;
;; dump
;;
;; begin
;;

(defparameter *root* "/fast/dc-store")
(defparameter *x-index-file* (join-paths *root* "index"))
(defparameter *dump-queue* nil)
(defparameter *index-mutex* (make-mutex :name "index-mutex"))
(defparameter *x-index* nil)
(defparameter *y-index* nil)

(defun dump-job (id)
  (let* ((article (db-cmd *db* :query
                          (:select 'id 'wid 'title 'vector 'affinity_count
                                   :from 'articles :where (:= 'id id))
                          :plist))
         (article-ds (ds article :map))
         (key (hash-string (freeze (ds-get article-ds :id))))
         (vector (gzip-sequence
                  (sequence-uint-to-bytes
                   (thaw (ds-get article-ds :vector))))))
    (ds-set article-ds :last-compared nil)
    (ds-set article-ds :most-similar nil)
    (ds-set article-ds :vector vector)
    (store-save *root* key article-ds)
    (with-mutex (*index-mutex*)
      (setf (gethash key *x-index*) id)
      (setf (gethash id *y-index*) key))))

(defun tp-dump (thread-count)
  (unless *dump-queue*
    (setf *dump-queue*
          (db-cmd *db* :query (:order-by (:select 'id :from 'articles) 'id)
                  :column)))
  (setf *x-index* (make-hash-table :test 'equal))
  (setf *y-index* (make-hash-table :test 'equal))
  (start-thread-pool "dump" thread-count *dump-queue* #'dump-job))

    

;;
;; end
;;
;; dump
;;
;; ----------------------------------------------------------------------


        
;; ----------------------------------------------------------------------
;;
;; affinity
;;
;; This is code is for the thread pool to perform the task of
;; calculating the affinity of articles.  Start the job by calling
;; (tp-affinity n), where n is the size of the thread pool.
;;
;; begin
;;

;; (defparameter *article-count*
;;   (db-cmd *db* :query (:select (:count '*) :from 'articles) :single))

;; (defparameter *affinity-busy* nil)
;; (defparameter *affinity-mutex* (make-mutex :name "affinity-mutex"))

;; (defun affinity-queue ()
;;   (db-cmd 
;;    *db* 
;;    :query 
;;    (:limit 
;;     (:order-by
;;      (:select 'id
;;               'preference
;;               'vector 
;;               'nvector 
;;               :from 'articles
;;               :where (:< 'affinity-count (1- *article-count*)))
;;      (:desc 'affinity-count)
;;      (:desc 'preference))
;;     1) :plist))

;; (defun affinity-queue-article-b (article-a)
;;   (with-mutex (*affinity-mutex*)
;;     (let ((a-id (getf article-a :id)))
;;       (loop for article-b =
;;            (db-cmd
;;             *db*
;;             :query
;;             (:limit
;;              (:select 
;;               'articles.id 
;;               'articles.vector 
;;               'articles.nvector 
;;               :from 'articles
;;               :where 
;;               (:not (:exists
;;                      (:select 1 :from 'affinity :where
;;                               (:or (:and (:= 'affinity.aid 'articles.id)
;;                                          (:= 'affinity.bid a-id))
;;                                    (:and (:= 'affinity.bid 'articles.id)
;;                                          (:= 'affinity.aid a-id)))))))
;;              1) :plist)
;;          while (member (getf article-b :id) *affinity-busy*)
;;          finally (progn
;;                    (push (getf article-b :id) *affinity-busy*)
;;                    (return article-b))))))

;; (defun affinity-job (article-a)
;;   (let* ((article-b (affinity-queue-article-b article-a))
;;          (id-a (getf article-a :id))
;;          (id-b (getf article-b :id))
;;          (vector-a (thaw (getf article-a :vector)))
;;          (vector-b (thaw (getf article-b :vector)))
;;          (nvector-a (thaw (getf article-a :nvector)))
;;          (nvector-b (thaw (getf article-b :nvector)))
;;          (affinity (affinity vector-a vector-b))
;;          (naffinity (affinity nvector-a nvector-b)))
;;     (db-cmd *db* :execute
;;             (:insert-into 'affinity :set 
;;                           'aid id-a 
;;                           'bid id-b 
;;                           'score affinity
;;                           'nscore naffinity
;;                           'last-thread (thread-name *current-thread*)))
;;     (db-cmd *db* :execute
;;             (:update 'articles :set 'affinity-count (:+ 1 'affinity-count)
;;                      :where (:= 'id id-a)))
;;     (db-cmd *db* :execute
;;             (:update 'articles :set 'affinity-count (:+ 1 'affinity-count)
;;                      :where (:= 'id id-b)))
;;     (with-mutex (*affinity-mutex*)
;;       (remove id-b *affinity-busy*))))
    
;; (defun tp-affinity (thread-count)
;;   (start-thread-pool
;;    "affinity"
;;    thread-count
;;    #'affinity-queue
;;    #'affinity-job))

;;
;; end
;;
;; affinity
;;
;; ----------------------------------------------------------------------


;; ----------------------------------------------------------------------
;;
;; affinity 2
;;
;; This is code is for the thread pool to perform the task of
;; calculating the affinity of articles.  Start the job by calling
;; (tp-affinity n), where n is the size of the thread pool.
;;
;; begin
;;

;; (defparameter *x-index-file* (join-paths *root* "index"))
;; (defparameter *affinity-queue* nil)
;; (defparameter *reference-article* nil)
;; (defparameter *reference-id* nil)
;; (defparameter *reference-key* nil)
;; (defparameter *reference-vector* nil)

;; (defun affinity-2-job (key)
;;   (let ((reference-affine (ds-get *reference-article* :affine))
;;         (id (gethash *x-index* key)))
;;     (unless (or (gethash id reference-affine)
;;                 (equal key *reference-key*))
;;       (let* ((article (ds (store-fetch *root* key) :map))
;;              (id (ds-get article :id))
;;              (vector (sequence-bytes-to-uint
;;                       (gunzip-sequence
;;                        (ds-get article :vector))))
;;              (affinity (affinity *reference-vector* vector))
;;              (affine (ds-get article :most-similar))
;;              (affinity-count (ds-get article :affinity-count))
;;              (reference-affine (ds-get *reference-article* :most-similar))
;;              (reference-affinity-count
;;               (ds-get *reference-article* :affinity-count)))
;;         (setf (gethash id reference-affine) affinity)
;;         (setf (gethash *reference-id* affine) affinity)
;;         (when (> (length (hash-keys reference-affine)) 100)
;;           (remhash (key-with-least-affinity reference-affine)
;;                    reference-affine))
;;         (when (> (length (hash-keys affine)) 100)
;;           (remhash (key-with-least-affinity affine) affine))
;;         (ds-set *reference-article* :most-similar reference-affine)
;;         (ds-set article :most-similar reference-affine)
;;         (ds-set article :affinity-count (1+ affinity-count))
;;         (ds-set *reference-article* :affinity-count
;;                 (1+ reference-affinity-count))
;;         (store-save *root* *reference-key* *reference-article*)
;;         (store-save *root* key article)))
;;     (ds-set *reference-article* :last-compared (list key id))))

;; (defun key-with-least-affinity (hash)
;;   (car (sort (hash-keys hash)
;;              (lambda (a b) (< (gethash a hash) (gethash b hash))))))

;; (defun tp-affinity-2 (reference-article-key 
;;                       first-counterpart
;;                       counterpart-count
;;                       thread-count)
;;   (setf *affinity-queue*
;;         (db-cmd *db* :query 
;;                 (:limit
;;                  (:order-by
;;                   (:select 'id :from 'articles)
;;                   'id)
;;                  counterpart-count first-counterpart)
;;                 :column))
;;   (setf *reference-article*
;;         (ds (store-fetch *root* reference-article-key) :map))
;;   (setf *reference-id* (ds-get *reference-article* :id))
;;   (setf *reference-key* reference-article-key)
;;   (setf *reference-vector*
;;         (sequence-bytes-to-uint
;;          (gunzip-sequence
;;           (ds-get *reference-article* :vector))))
;;   (start-thread-pool 
;;    "affinity-2" thread-count *affinity-queue* #'affinity-2-job))
  


;;
;; end
;;
;; affinity
;;
;; ----------------------------------------------------------------------


;;
;; dump
;;

;; (defparameter *last-dumped-id* 0)
;; (defparameter *dump-progress* 0)
;; (defparameter *stop-dump* nil)

;; (defun load-index ()
;;   (setf *x-index* (make-hash-table :test 'equal))
;;   (setf *y-index* (make-hash-table :test 'equal))
;;   (if (file-exists *x-index-file*)
;;       (with-open-file (s *x-index-file*)
;;         (setf *x-index* (make-hash-table :test 'equal))
;;         (setf *y-index* (make-hash-table :test 'equal))
;;         (loop with count = 0
;;            for line = (thaw (read-line s nil))
;;            while line do
;;              (setf (gethash (car line) *x-index*) (second line))
;;              (setf (gethash (second line) *y-index*) (first line))
;;              (incf count)
;;            finally (return count)))
;;       0))

;; (defun save-index ()
;;     (with-open-file (f *x-index-file* :direction :output
;;                        :if-exists :supersede)
;;       (loop for key being the hash-keys in *x-index* using (hash-value value)
;;          counting key
;;          do (format f "~a ~a~%" key value))))

;; (defun dump-articles ()
;;   (let ((ids (db-cmd 
;;               *db* :query (:order-by (:select 'id :from 'articles) 'id)
;;               :column)))
;;     (setf *dump-progress* 0)
;;     (load-index)
;;     (loop for id in ids
;;        for article = (db-cmd 
;;                       *db* :query 
;;                       (:select 'id 'wid 'title 'vector 'affinity_count
;;                                :from 'articles :where (:= 'id id))
;;                       :plist)
;;        for article-ds = (ds article :map)
;;        for key = (hash-string (freeze (ds-get article-ds :id)))
;;        for vector = (thaw (ds-get article-ds :vector))
;;        for byte-vector = (sequence-uint-to-bytes vector)
;;        for compressed-byte-vector = (gzip-sequence byte-vector)
;;        until *stop-dump*
;;        do
;;          (ds-set article-ds :last-compared nil)
;;          (ds-set article-ds :most-similar nil)
;;          (ds-set article-ds :vector compressed-byte-vector)
;;          (store-save *root* key article-ds)
;;          (setf (gethash key *x-index*) id)
;;          (setf (gethash id *y-index*) key)
;;          (incf *dump-progress*)
;;        finally (save-index))))

;; (defun dump-progress (seconds)
;;   (let ((a *dump-progress*)
;;         (b (progn (sleep seconds) *dump-progress*)))
;;     (/ (- b a) (float seconds))))

;; (defun article-by-title (title)
;;   (ds (db-cmd *db* :query (:select '* :from 'articles 
;;                                    :where (:= 'title title)) :plist)
;;       :map))

;; (defun article-by-id (id)
;;   (db-cmd *db* :query (:select '* :from 'articles :where (:= 'id id)) :plist))

;; (defun find-article-in-store (article)
;;   (let* ((key (hash-string (freeze (ds-get (ds article :map) :id))))
;;          (store-article (store-fetch *root* key)))
;;     (list (ds-get store-article :id)
;;           (ds-get store-article :title))))

;; (defun get-some-ids (n)
;;   (db-cmd *db* :query 
;;           (:limit (:order-by (:select 'id :from 'articles) 'id) n)
;;           :column))

;; (defun store-article-by-id (id)
;;   (ds (store-fetch *root* (hash-string (freeze id))) :map))

;; (defun add-affine (article id affinity)
;;   (let ((affine (ds-get article :affine))
;;         (max 100))
;;     (if (< (length affine) max)
;;         (let ((new-affine (cons (list affinity id) affine)))
;;           (ds-set article :affine (sort new-affine #'> :key #'car)))
;;         (when (< affinity (caar (last affine)))
;;           (setf (elt affine (1- max)) (list affinity id))
;;           (ds-set article :affine (sort affine #'> :key #'car))))
;;     article))

;; (defun store-article-affinity (id1 id2 &key update save-place)
;;   (when (and id1 id2)
;;     (let ((a1 (store-article-by-id id1))
;;           (a2 (store-article-by-id id2))
;;           (key1 (hash-string (freeze id1)))
;;           (key2 (hash-string (freeze id2))))
;;       (when (and a1 a2)
;;         (let ((affinity (affinity (thaw (ds-get a1 :vector))
;;                                   (thaw (ds-get a2 :vector)))))
;;           (when update
;;             (setf a1 (add-affine a1 id2 affinity))
;;             (setf a2 (add-affine a2 id1 affinity))
;;             (when save-place
;;               (ds-set a1 :last-
;;             (store *root* nil key1 a1)
;;             (store *root* nil key2 a2)))))))


;; (defun decompress-vector (vector)
;;   (sequence-bytes-to-uint (gunzip-sequence vector)))

;; (defun bogus-sum ()
;;   (loop for key being the hash-keys in *x-index*
;;      for n from 1 to 1000
;;      for article-ds = (ds (store-fetch *root* key) :map)
;;      for vector = (sequence-bytes-to-uint
;;                    (gunzip-sequence
;;                     (ds-get article-ds :vector)))
;;      for vector-average = (/ (reduce '+ vector) (float (length vector)))
;;      summing vector-average into total
;;      counting key into count
;;      finally (return (list :count count :average (/ total 1000.0)))))

;; (defun load-vectors ()
;;   (db-cmd *db* :doquery (:select 'id 'vector :from 'articles) (id vector)
;;           (setf (gethash id *all-vectors*) (list (thaw vector)))))

;; (defun serialize-vectors (filename)
;;   (make-thread
;;    (lambda ()
;;      (with-open-file (f filename :direction :output :if-exists :supersede)
;;        (db-cmd *db* :doquery (:select 'id 'wid 'vector :from 'articles)
;;                (id wid vector)
;;                (format f "'(~a ~a #(~{~a~^ ~}~%" id wid 
;;                        (map 'list 'identity (thaw vector))))))
;;    :name "serialize-vectors"))

;; (defparameter *result* nil)
;; (defparameter *result-1* nil)
;; (defun bogus-op ()
;;   (loop with start-time = (get-universal-time)
;;      for key being the hash-keys in *all-vectors*
;;      for vector = (sequence-bytes-to-uint
;;                    (gunzip-sequence 
;;                     (car (gethash key *all-vectors*))))
;;      for vector-average = (/ (reduce '+ vector) 19656.0)
;;      counting key into count
;;      summing vector-average into sum
;;      finally (setf *result* (list :count count
;;                                   :average (/ sum count)
;;                                   :time (- (get-universal-time) 
;;                                            start-time)))))

;; (defun bogus-op-1 ()
;;   (loop with start-time = (get-universal-time)
;;      for key being the hash-keys in *all-vectors*
;;      for vector = (car (gethash key *all-vectors*))
;;      for vector-average = (/ (reduce '+ vector) 19656.0)
;;      counting key into count
;;      summing vector-average into sum
;;      finally (return (setf *result-1* (list :count count
;;                                             :average (/ sum count)
;;                                             :time (- (get-universal-time)
;;                                                      start-time))))))
;; (defun load-test (thread-count)
;;   (loop for a from 0 below thread-count collect
;;        (let ((m a)
;;              (n thread-count))
;;          (make-thread
;;           (lambda ()
;;             (with-open-file (handle *vectors-file*)
;;               (loop for raw-line = (read-line handle nil)
;;                  while raw-line
;;                  for line = (format nil "~a))" (read-line handle))
;;                  for (id wid uncompressed-vector) = (thaw (subseq line 1))
;;                  for vector = (gzip-sequence
;;                                (sequence-uint-to-bytes uncompressed-vector))
;;                  do (setf (gethash wid *all-vectors*) (list vector)))))
;;           :name (format nil "time-load-~a" m)))
;;      into threads
;;      finally (loop for thread in threads do (join-thread thread))))

;; (defparameter *raw-line-buffer* nil)
;; (defparameter *raw-line-buffer-mutex*
;;   (make-mutex :name "raw-line-buffer-mutex"))
;; (defparameter *total-read* 0)

;; (defun process-raw-line (tid)
;;   (loop 
;;      with total-processed = 0
;;      for raw-line = (with-mutex (*raw-line-buffer-mutex*)
;;                          (pop *raw-line-buffer*))
;;      until (or (and (null raw-line) *stop-threads*) *really-stop-threads*)
;;      when raw-line
;;      do (destructuring-bind (id wid uncompressed-vector)
;;             (thaw (format nil "~a))" (subseq raw-line 1)))
;;           (declare (ignore id))
;;           (let ((vector (gzip-sequence
;;                          (sequence-uint-to-bytes uncompressed-vector))))
;;             (setf (gethash wid *all-vectors*) (list tid vector)))
;;           (incf total-processed))
;;      finally (return total-processed)))

;; (defun thread-load-vectors ()
;;   (with-open-file (handle *vectors-file*)
;;     (setf *stop-threads* nil)
;;     (setf *raw-line-buffer* nil)
;;     (setf *total-read* 0)
;;     (sb-ext:gc :full t)
;;     (let ((threads (loop for a from 1 to *thread-count* collect
;;                         (make-thread
;;                          (lambda () (process-raw-line a))
;;                          :name (format nil "thread-load-vectors-~2,'0d" a)))))
;;       (loop for raw-line = (read-line handle nil)
;;          while raw-line
;;          do (with-mutex (*raw-line-buffer-mutex*)
;;               (push raw-line *raw-line-buffer*))
;;            (loop while (> (length *raw-line-buffer*) (* *thread-count* 2))
;;              do (sleep 1))
;;            (incf *total-read*))
;;       (setf *stop-threads* t)
;;       (loop for thread in threads summing (join-thread thread)))))
      

;; (defun load-vectors-3 ()
;;   (with-open-file (handle *vectors-file*)
;;     (setf *all-vectors* (make-hash-table :test 'equal :size *group-size*))
;;     (loop for a from 1 to *group-size*
;;        for raw-line = (read-line handle nil)
;;        while raw-line do
;;          (destructuring-bind (id wid vector)
;;              (thaw (format nil "~a))" (subseq raw-line 1)))
;;            (declare (ignore id))
;;            (setf (gethash wid *all-vectors*) (list vector))))))

;; (defun load-vectors-4 ()
;;   (setf *all-vectors* (make-hash-table :test 'equal :size *group-size*))
;;   (db-cmd *db* :doquery 
;;           (:limit 
;;            (:order-by (:select 'wid 'vector :from 'articles) 'wid)
;;            *group-size*)
;;           (wid vector)
;;           (setf (gethash wid *all-vectors*) (list (thaw vector)))))

;; (defun copy-vectors ()
;;   (loop for wid being the hash-keys in *all-vectors* 
;;      using (hash-value value)
;;      for vector = (format nil "{~{~a~^,~}}" (map 'list 'identity (car value)))
;;      do (db-cmd *db* :execute (:insert-into 'vectors :set 'wid wid 'vector vector))))

;; (defparameter *vectors-5* nil)
;; (defun load-vectors-5 ()
;;   (setf *vectors-5* (make-hash-table :test 'equal :size *group-size*))
;;   (db-cmd *db* :doquery
;;           (:limit
;;            (:select 'wid 'vector :from 'vectors)
;;            *group-size*)
;;           (wid vector)
;;           (setf (gethash wid *vectors-5*) (list vector))))


;; (defparameter *article-count* 4078970)
;; (defparameter *article-count* 2000)
;; (defparameter *group-size* 1000)
;; (defparameter *vectors-file*
;;   "/home/macnod/data/chattermancy/wikipedia/vectors.dat")
;; (defparameter *stop-threads* nil)
;; (defparameter *really-stop-threads* nil)
;; (defparameter *vectors* nil)
;; (defparameter *queue* nil)
;; (defparameter *thread-count* 8)
;; (defparameter *affinity* (make-hash-table :test 'equal :size *article-count*
;;                                           :synchronized t))
;; (defparameter *queue-mutex* (make-mutex :name "queue"))
;; (defparameter *affinity-mutex* (make-mutex :name "affinity"))

;; (defun all-vectors-sample ()
;;   (mapcar (lambda (x) (destructuring-bind (tid vector) (gethash x *all-vectors*)
;;                         (list tid (length vector) (subseq vector 0 20))))
;;           (subseq (hash-keys *vectors*) 0 9)))

;; (defun load-vectors (offset limit)
;;   (setf *vectors* (make-hash-table :test 'equal :size limit))
;;   (db-cmd *db* :doquery 
;;           (:limit
;;            (:order-by (:select 'wid 'vector :from 'articles) 'wid)
;;            limit offset)
;;           (wid vector)
;;           (setf (gethash wid *vectors*) (thaw vector)))
;;   (setf *queue* (hash-keys *vectors*)))

;; (defun article-affinity (reference-wid)
;;   (let ((reference-vector
;;          (thaw (db-cmd *db* :query 
;;                        (:select 'vector :from 'articles
;;                                 :where (:= 'wid reference-wid))
;;                        :single))))
;;     (loop for offset from 0 to *article-count* by *group-size*
;;        do (load-vectors offset *group-size*)
;;          (group-affinity reference-wid reference-vector))))

;; (defun group-affinity (reference-wid reference-vector)
;;   (let ((threads (loop for a from 1 to *thread-count*
;;                     for tname = (format nil "group-affinity-thread-~2,'0d" a)
;;                     collect (let ((tid a))
;;                               (make-thread 
;;                                (lambda () (group-affinity-thread 
;;                                            tid reference-wid reference-vector))
;;                                :name tname)))))
;;     (loop for thread in threads do (join-thread thread))))

;; (defun group-affinity-thread (tid reference-wid reference-vector)
;;   (loop for wid = (with-mutex (*queue-mutex*) (pop *queue*))
;;        for vector = (gethash wid *vectors*)
;;        while wid
;;        unless (= reference-wid wid)
;;        do (with-mutex (*affinity-mutex*)
;;             (setf (gethash (sort (list reference-wid wid) '<) *affinity*)
;;                   (list tid (affinity reference-vector vector))))))

;; (defparameter *progress* nil)
;; (defun populate-compressed-vector-column ()
;;   (setf *progress* 0)
;;   (setf *stop-threads* nil)
;;   (let ((wids (db-cmd *db*
;;                       :query
;;                       (:limit (:select 'wid :from 'articles-1)
;;                               100)
;;                       :column)))
;;     (loop for wid in wids
;;        for frozen-vector = (db-cmd *db*
;;                                    :query (:select 'vector :from 'articles-1
;;                                            :where (:= 'wid wid))
;;                                    :single)
;;        for vector = (format nil "{~{~a~^,~}}"
;;                             (map 'list 'identity
;;                                  (gzip-sequence
;;                                   (sequence-uint-to-bytes
;;                                    (thaw frozen-vector)))))
;;        do (db-cmd *db*
;;                   :execute (:update 'articles-1
;;                             :set 'compressed-vector vector
;;                             :where (:= 'wid wid)))
;;          (incf *progress*))))

;; (defparameter *vlog1* nil)
;; (defun populate-compressed-vector-column-1 ()
;;   (let* ((wids (map 'vector 'identity
;;                     (db-cmd *db*
;;                             :query
;;                             (:limit (:select 'wid :from 'articles-1)
;;                                     1000)
;;                             :column)))
;;          (wid-count (length wids))
;;          (step 20))
;;     (format t "wid-count=~a~%" wid-count)
;;     (loop for index from 0 below wid-count by step
;;        for top = (if (>= (+ index step) wid-count) (- wid-count index) step)
;;        do
;;          (format t "index=~a; top=~a~%" index top)
;;          (loop for a from 0 below top collect
;;               (let ((wid (aref wids (+ index a)))
;;                     (name (format nil "compress-vector-~2,'0d" a)))
;;                 (make-thread 
;;                  (lambda ()
;;                    (let* ((vector
;;                            (db-cmd *db* :query 
;;                                    (:select 'vector :from 'articles-1
;;                                     :where (:= 'wid wid))
;;                                    :single)))
;;                      (format nil "{~{~a~^,~}}"
;;                              (map 'list 'identity
;;                                   (gzip-sequence
;;                                    (sequence-uint-to-bytes
;;                                     (thaw vector)))))))
;;                  :name name))
;;             into threads
;;             finally
;;               (loop for thread in threads
;;                  collect (join-thread thread) into compressed-vectors
;;                  finally 
;;                    (db-cmd 
;;                     *db* :execute 
;;                     (:select
;;                      (:update-compressed-vectors-1
;;                       (aref wids (+ index 0)) (elt compressed-vectors 0)
;;                       (aref wids (+ index 1)) (elt compressed-vectors 1)
;;                       (aref wids (+ index 2)) (elt compressed-vectors 2)
;;                       (aref wids (+ index 3)) (elt compressed-vectors 3)
;;                       (aref wids (+ index 4)) (elt compressed-vectors 4)
;;                       (aref wids (+ index 5)) (elt compressed-vectors 5)
;;                       (aref wids (+ index 6)) (elt compressed-vectors 6)
;;                       (aref wids (+ index 7)) (elt compressed-vectors 7)
;;                       (aref wids (+ index 8)) (elt compressed-vectors 8)
;;                       (aref wids (+ index 9)) (elt compressed-vectors 9)
;;                       (aref wids (+ index 10)) (elt compressed-vectors 10)
;;                       (aref wids (+ index 11)) (elt compressed-vectors 11)
;;                       (aref wids (+ index 12)) (elt compressed-vectors 12)
;;                       (aref wids (+ index 13)) (elt compressed-vectors 13)
;;                       (aref wids (+ index 14)) (elt compressed-vectors 14)
;;                       (aref wids (+ index 15)) (elt compressed-vectors 15)
;;                       (aref wids (+ index 16)) (elt compressed-vectors 16)
;;                       (aref wids (+ index 17)) (elt compressed-vectors 17)
;;                       (aref wids (+ index 18)) (elt compressed-vectors 18)
;;                       (aref wids (+ index 19)) (elt compressed-vectors 19)))))))))

;; (defparameter *stop* nil)
;; (defun populate-compressed-vector-column ()
;;   (let* ((wids (map 'vector 'identity
;;                     (db-cmd *db*
;;                             :query
;;                             (:select 'wid :from 'articles
;;                              :where (:is-null 'compressed-vector))
;;                             :column)))
;;          (wid-count (length wids))
;;          (step 20))
;;     (format t "wid-count=~a~%" wid-count)
;;     (setf *stop* nil)
;;     (loop for index from 0 below (- wid-count step) by step
;;        for top = (if (>= (+ index step) wid-count) (- wid-count index) step)
;;        until *stop*
;;        do
;;          (setf *progress* index)
;;          (loop for a from 0 below top collect
;;               (let ((wid (aref wids (+ index a)))
;;                     (name (format nil "compress-vector-~2,'0d" a)))
;;                 (make-thread 
;;                  (lambda ()
;;                    (let* ((vector
;;                            (db-cmd *db* :query 
;;                                    (:select 'vector :from 'articles
;;                                     :where (:= 'wid wid))
;;                                    :single)))
;;                      (format nil "{~{~a~^,~}}"
;;                              (map 'list 'identity
;;                                   (gzip-sequence
;;                                    (sequence-uint-to-bytes
;;                                     (thaw vector)))))))
;;                  :name name))
;;             into threads
;;             finally
;;               (loop for thread in threads
;;                  collect (join-thread thread) into compressed-vectors
;;                  finally 
;;                    (db-cmd 
;;                     *db* :execute 
;;                     (:select
;;                      (:update-compressed-vectors
;;                       (aref wids (+ index 0)) (elt compressed-vectors 0)
;;                       (aref wids (+ index 1)) (elt compressed-vectors 1)
;;                       (aref wids (+ index 2)) (elt compressed-vectors 2)
;;                       (aref wids (+ index 3)) (elt compressed-vectors 3)
;;                       (aref wids (+ index 4)) (elt compressed-vectors 4)
;;                       (aref wids (+ index 5)) (elt compressed-vectors 5)
;;                       (aref wids (+ index 6)) (elt compressed-vectors 6)
;;                       (aref wids (+ index 7)) (elt compressed-vectors 7)
;;                       (aref wids (+ index 8)) (elt compressed-vectors 8)
;;                       (aref wids (+ index 9)) (elt compressed-vectors 9)
;;                       (aref wids (+ index 10)) (elt compressed-vectors 10)
;;                       (aref wids (+ index 11)) (elt compressed-vectors 11)
;;                       (aref wids (+ index 12)) (elt compressed-vectors 12)
;;                       (aref wids (+ index 13)) (elt compressed-vectors 13)
;;                       (aref wids (+ index 14)) (elt compressed-vectors 14)
;;                       (aref wids (+ index 15)) (elt compressed-vectors 15)
;;                       (aref wids (+ index 16)) (elt compressed-vectors 16)
;;                       (aref wids (+ index 17)) (elt compressed-vectors 17)
;;                       (aref wids (+ index 18)) (elt compressed-vectors 18)
;;                       (aref wids (+ index 19)) (elt compressed-vectors 19)))))))))


;; ----------------------------------------------------------------------
;;
;; affinity 3
;;
;; This code is for the thread pool
;;
;; begin
;;

;; (defparameter *reference-wid* nil)
;; (defparameter *reference-vector* nil)
;; (defparameter *affinity-3-queue* nil)

;; (defun fetch-vector (wid)
;;   (sequence-bytes-to-uint
;;    (gunzip-sequence
;;     (db-cmd *db* :query (:select 'compressed-vector :from 'articles
;;                          :where (:= 'wid wid))
;;             :single))))

;; (defun affinity-3-job (wid)
;;   (let* ((vector (fetch-vector wid))
;;          (affinity (affinity *reference-vector* vector)))
;;     (db-cmd *db* :execute (:insert-into 'affinity
;;                            :set 'aid *reference-wid*
;;                                 'bid wid
;;                                 'score affinity))))

;; (defun tp-affinity-3 (reference-wid)
;;   (setf *reference-wid* reference-wid
;;         *reference-vector* (fetch-vector reference-wid)
;;         *affinity-3-queue* (db-cmd
;;                             *db* :query
;;                             (:order-by
;;                              (:select 'wid :from 'articles
;;                               :where (:<> 'wid *reference-wid*))
;;                              'wid)
;;                             :column))
;;   (start-thread-pool "affinity-3" 8 *affinity-3-queue* #'affinity-3-job))

;;
;; end
;;
;; affinity 3
;;
;; ----------------------------------------------------------------------


;; ----------------------------------------------------------------------
;;
;; affinity 5
;;
;; This code is for the thread pool
;;
;; begin
;;

;; (defparameter *reference-wid* nil)
;; (defparameter *reference-vector* nil)
;; (defparameter *affinity* nil)
;; (defparameter *min-score* 0.0)
;; (defparameter *min-key* nil)
;; (defparameter *affinity-mutex* nil)
;; (defparameter *page-size* 100000)
;; (defparameter *page* 1)
;; (defparameter *affine-count* 1000)
;; (defparameter *start-time* nil)
;; (defparameter *stop-time* nil)
;; (defparameter *affinity-queue* nil)
;; (defparameter *vectors* nil)
;; (defparameter *status* nil)

;; (defun fetch-vector (wid)
;;   (sequence-bytes-to-uint
;;    (gunzip-sequence
;;     (db-cmd *db* :query (:select 'compressed-vector :from 'articles
;;                          :where (:= 'wid wid))
;;             :single))))

;; (defun find-min ()
;;   (unless (zerop (hash-table-count *affinity*))
;;     (loop with min-key = nil
;;        with min-score = 1
;;        for key being the hash-keys in *affinity* using (hash-value score)
;;        when (< score min-score)
;;        do (setf min-score min-score)
;;          (setf min-key key)
;;        finally (progn
;;                  (setf *min-score* min-score)
;;                  (setf *min-key* min-key)))))

;; (defun affinity-5-job (wid)
;;   (unless (= *reference-wid* wid)
;;     (let* ((vector (sequence-bytes-to-uint
;;                     (gunzip-sequence
;;                      (gethash wid *vectors*))))
;;            (affinity (affinity *reference-vector* vector)))
;;       (with-mutex (*affinity-mutex*)
;;         (if (< (hash-table-count *affinity*) *affine-count*)
;;             (setf (gethash wid *affinity*) affinity)
;;             (progn
;;               (find-min)
;;               (when (> affinity *min-score*)
;;                 (remhash *min-key* *affinity*)
;;                 (setf (gethash wid *affinity*) affinity))))))))

;; (defun tp-affinity-5 (reference-wid)
;;   (setf *status* "loading vectors")
;;   (setf *reference-wid* reference-wid
;;         *reference-vector* (fetch-vector reference-wid))
;;   (format t "Loading vectors.~%")
;;   (time (affinity-5-load-vectors *page-size* *page*))
;;   (setf *affinity-queue* (hash-keys *vectors*)
;;         *affinity-mutex* (make-mutex :name "affinity-5-mutex")
;;         *affinity* (make-hash-table :size *affine-count*)
;;         *start-time* (get-universal-time))
;;   (sb-ext:gc :full t)
;;   (format t "Starting affinity-5 thread pool.~%")
;;   (setf *status* "computing affinity")
;;   (start-thread-pool "affinity-5" 8 *affinity-queue*
;;                      #'affinity-5-job #'affinity-5-finally))

;; (defun affinity-5-clear-memory ()
;;   (setf *reference-vector* nil
;;         *vectors* nil
;;         *affinity-queue* nil
;;         *affinity* nil)
;;   (sb-ext:gc :full t))
  

;; (defun affinity-5-finally ()
;;   (setf *status* "done")
;;   (setf *stop-time* (get-universal-time)))

;; (defun affinity-5-load-vectors (page-size page)
;;   (setf *vectors* (make-hash-table :size *page-size* :synchronized t))
;;   (db-cmd
;;    *db* :doquery 
;;    (:limit
;;     (:order-by
;;      (:select 'wid 'compressed-vector :from 'articles
;;       :where (:<> 'wid *reference-wid*))
;;      'wid)
;;     page-size (* (1- page) page-size))
;;    (wid compressed-vector)
;;    (setf (gethash wid *vectors*) compressed-vector)))

;; (defun affinity-5-store-results ()
;;   (loop for wid being the hash-keys in *affinity* using (hash-value score)
;;      do (db-cmd *db* :execute
;;                 (:insert-into 'affinity
;;                  :set 'aid *reference-wid*
;;                       'bid wid
;;                       'score score))))
                
;;
;; end
;;
;; affinity 5
;;
;; ----------------------------------------------------------------------

(defun change-per-second (symbol &optional (seconds 10))
  (let ((v1 (symbol-value symbol))
        (v2 (progn (sleep seconds) (symbol-value symbol))))
    (/ (- v2 v1) (float seconds))))

(defun total-time-for-n-records (change-per-second record-count)
  (let* ((seconds (/ record-count (float change-per-second)))
         (hours (/ seconds 3600.0))
         (days (/ hours 24.0)))
    (list :@ change-per-second :to-go record-count
          :seconds seconds :hours hours :days days)))


;; ----------------------------------------------------------------------
;;
;; affinity 4
;;
;; This code is for the thread pool
;;
;; begin
;;

(defparameter *reference-wid* nil)
(defparameter *reference-vector* nil)
(defparameter *affinity-queue* nil)
(defparameter *affinity* nil)
(defparameter *smallest-score* 0.0)
(defparameter *smallest-index* nil)
(defparameter *affinity-mutex* nil)
(defparameter *batch-size* 1000)
(defparameter *start-time* nil)
(defparameter *stop-time* nil)
(defparameter *thread-count* 10)
(defparameter *affinity-store* nil)

(defun fetch-vector-4 (wid)
  (sequence-bytes-to-uint
   (gunzip-sequence
    (db-cmd *db* :query (:select 'compressed-vector :from 'articles
                                 :where (:= 'wid wid))
            :single))))

(defun set-smallest ()
  (unless (zerop (length *affinity*))
    (loop with smallest-index = 0
       with smallest-score = 1.0
       for index from 0 below (length *affinity*)
       for current-score = (second (aref *affinity* index))
       when (< current-score smallest-score)
       do (setf smallest-index index)
         (setf smallest-score current-score)
       finally (progn
                 (setf *smallest-index* smallest-index)
                 (setf *smallest-score* smallest-score)))))

(defun affinity-4-job (wid)
  (let* ((vector (fetch-vector-4 wid))
         (affinity (affinity *reference-vector* vector)))
    (with-mutex (*affinity-mutex*)
      (if (< (length *affinity*) *batch-size*)
          (progn
            (vector-push-extend (list wid affinity) *affinity*)
            (when (= (length *affinity*) *batch-size*)
              (set-smallest)))
          (when (> affinity *smallest-score*)
            (setf (aref *affinity* *smallest-index*)
                  (list wid affinity))
            (set-smallest))))))

(defun tp-affinity-4 (reference-wid)
  (setf *reference-wid* reference-wid
        *reference-vector* (fetch-vector-4 reference-wid)
        *affinity-queue* (db-cmd
                            *db* :query
                            (:order-by
                             (:select 'wid :from 'articles
                              :where (:<> 'wid *reference-wid*))
                             'wid)
                            :column)
        *affinity-mutex* (make-mutex :name "affinity-4-mutex")
        *affinity* (make-array *batch-size* :fill-pointer 0)
        *smallest-score* 0
        *smallest-index* 0
        *start-time* (get-universal-time))
  (start-thread-pool "affinity-4" *thread-count* *affinity-queue*
                     #'affinity-4-job #'affinity-4-finally))

(defun affinity-4-finally ()
  (setf *stop-time* (get-universal-time)))

(defun affinity-4-store-results ()
  (loop for (reference-wid affinity) in *affinity-store*
     do (loop for (wid score) across affinity
           do (db-cmd *db* :execute
                      (:insert-into 'affinity
                       :set 'aid reference-wid
                            'bid wid
                            'score score)))))

(defun affinity-4 (xwids)
  (setf *affinity-store* nil)
  (make-thread
   (lambda ()
     (loop for xwid in xwids do
          (tp-affinity-4 xwid)
          (sleep 60)
          (loop while (< *dc-thread-pool-progress* 4078967) do (sleep 60)
             finally (push (list xwid (copy-seq *affinity*)) *affinity-store*))))
   :name "affinity-4-loop"))

(defun affinity-4-export (wids filename)
  (with-open-file (file filename :direction :output :if-exists :supersede)
    (loop for wid in wids
       do (db-cmd *db* :doquery
                  (:select 'aid 'bid 'score :from 'affinity
                   :where (:= 'aid wid))
                  (aid bid score)
                  (format file "~a ~a ~a~%" aid bid score)))))
       
(defun affinity-4-import (filename)
  (with-open-file (file filename)
    (loop for line = (read-line file nil)
       while line
       for (reference-wid wid score) = (split " +" line)
       do (db-cmd *db* :execute 
                  (:insert-into 'affinity
                   :set 'aid reference-wid
                        'bid wid
                        'score score)))))

;;
;; end
;;
;; affinity 4
;;
;; ----------------------------------------------------------------------

(defun fast-compress (v)
  (loop with c = nil
     with l = (length v)
     for i from 0 below l
     for n = (aref v i)
     do (if (zerop n)
            (let ((run (loop for j = i then (1+ j)
                          while (< j l)
                          for m = n then (aref v j)
                          while (zerop m)
                          counting m into run
                          finally (return (list m run)))))
              (push (- (second run)) c)
              (unless (zerop (first run)) (push (first run) c))
              (incf i (second run)))
            (push n c))
     finally (return (nreverse c))))

(defun fast-decompress (l)
  (map 'vector 'identity
       (loop for n in l appending
            (if (< n 0) (loop for a from 1 to (- n) collect 0) (list n)))))

(defun fetch-vector (wid)
  (thaw
   (db-cmd *db* :query 
           (:select 'vector :from 'articles :where (:= 'wid wid))
           :single)))

(defun compute-cvector (wid)
  (fast-compress (fetch-vector wid)))

(defparameter *cvector-progress* 0)
(defun update-article-cvector (wid)
  (let ((cvector (format nil "{~{~a~^,~}}" (compute-cvector wid))))
    (db-cmd *db* :execute
            (:update 'articles :set 'cvector cvector
                     :where (:= 'wid wid)))))

(defun populate-cvectors ()
  (let ((wids (fetch-all-wids)))
    (loop for wid in wids do
         (update-article-cvector wid)
         (incf *cvector-progress*))))

(defun reference-articles (&key (limit 20) formatted)
  (let* ((articles
          (db-cmd 
           *db* :query 
           (:limit 
            (:order-by 
             (:select 'wid 'preference 'title :from 'articles :where 
                      (:exists (:select 1 :from 'affinity :where 
                                        (:= 'articles.wid 'affinity.aid))))
             (:desc 'articles.preference))
            limit)))
         (format (format nil (concatenate
                              'string
                              "~~&WID~~~dt PREF~~~dtTITLE"
                              "~~{~~&~~a~~~dt~~~d<~~a~~>~~~dt~~a~~}")
                      10 17 10 5 17)))
    (if formatted
        (format t format (flatten articles))
        articles)))

(defun set-preference (title-or-wid preference)
  (if (numberp title-or-wid)
      (db-cmd *db* :execute
              (:update 'articles :set 'preference preference
                       :where (:= 'wid title-or-wid)))
      (db-cmd *db* :execute
              (:update 'articles :set 'preference preference
                       :where (:= 'title title-or-wid)))))

;; (defun load-cvectors (&optional (count 4078968))
;;   (loop for wid in (fetch-all-wids)
;;      for index from 1 to count
;;      do (setf (gethash wid *vectors*) (fetch-vector wid))))

;; ----------------------------------------------------------------------
;;
;; load-cvectors
;;
;; This code is for the thread pool
;;
;; begin
;;

(defparameter *cvectors* nil)
(defparameter *load-cvectors-queue* nil)
(defparameter *start-time* nil)
(defparameter *run-time* nil)

(defun fetch-all-wids (&key (reference-wid 0) (limit 4078968))
  (db-cmd
   *db* :query
   (:limit
    (:order-by
     (:select 'wid :from 'articles
              :where (:<> 'wid reference-wid))
     'wid)
    limit)
    :column))

(defun fetch-cvector (wid)
  (db-cmd *db* :query (:select 'cvector :from 'articles :where (:= 'wid wid))
          :single))

(defun load-cvectors-job (wid)
  (setf (gethash wid *cvectors*) (fetch-cvector wid)))

(defun load-cvectors-finally ()
  (setf *run-time* (- (get-universal-time) *start-time*)))

(defun tp-load-cvectors (limit)
  (setf *cvectors* nil)
  (sb-ext:gc :full t)
  (setf *cvectors* (make-hash-table :size limit)
        *load-cvectors-queue* (fetch-all-wids :limit limit)
        *start-time* (get-universal-time))
  (start-thread-pool "load-cvectors" 8 *load-cvectors-queue* 
                     #'load-cvectors-job
                     #'load-cvectors-finally))

;;
;; end
;;
;; load-cvectors
;;
;; ----------------------------------------------------------------------


select a.wid, a.preference, a.title from articles a where exists (select aid from affinity where aid = a.wid) order by a.preference desc;

(defun computed-articles (&optional (limit 4078968))
  (db-cmd
   *db*
   :query
   (:limit
    (:order-by
     (:select 'a.wid 'a.preference 'a.title
              :from (:as 'articles 'a)
              :where (:exists (:select 'aid :from 'affinity
                                       :where (:= 'aid 'a.wid))))
     (:desc 'a.preference))
    limit)
   :plists))



;; ----------------------------------------------------------------------
;;
;; affinity 4
;;
;; This code is for the thread pool
;;
;; begin
;;


;;
;; end
;;
;; affinity 4
;;
;; ----------------------------------------------------------------------
